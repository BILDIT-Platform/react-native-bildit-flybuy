import * as WebSocket from "ws";
import { ClientOptions } from "./client-options";
export declare const corePlugins: (((reactotron: Reactotron<ReactotronCore>) => {
    features: {
        log: (...args: any[]) => void;
        logImportant: (...args: any[]) => void;
        debug: (message: any, important?: boolean) => void;
        warn: (message: any) => void;
        error: (message: any, stack: any) => void;
    };
}) | ((reactotron: Reactotron<ReactotronCore>) => {
    features: {
        image: ({ uri, preview, filename, width, height, caption }: {
            uri: any;
            preview: any;
            filename: any;
            width: any;
            height: any;
            caption: any;
        }) => void;
    };
}) | ((reactotron: Reactotron<ReactotronCore>) => {
    features: {
        benchmark: (title: any) => {
            step: (stepTitle: any) => void;
            stop: (stopTitle: any) => void;
            last: (stopTitle: any) => void;
        };
    };
}) | ((reactotron: Reactotron<ReactotronCore>) => {
    features: {
        stateActionComplete: (name: any, action: any, important?: boolean) => void;
        stateValuesResponse: (path: any, value: any, valid?: boolean) => void;
        stateKeysResponse: (path: any, keys: any, valid?: boolean) => void;
        stateValuesChange: (changes: any) => void;
        stateBackupResponse: (state: any) => void;
    };
}) | ((reactotron: Reactotron<ReactotronCore>) => {
    features: {
        apiResponse: (request: any, response: any, duration: any) => void;
    };
}) | ((reactotron: Reactotron<ReactotronCore>) => {
    features: {
        clear: () => void;
    };
}) | ((reactotron: Reactotron<ReactotronCore>) => {
    onCommand: ({ type, payload }: {
        type: string;
        payload?: any;
    }) => void;
    features: {
        repl: (name: string, value: import("./plugins/repl").AcceptableRepls) => void;
    };
}))[];
export declare enum ArgType {
    String = "string"
}
export interface CustomCommandArg {
    name: string;
    type: ArgType;
}
export interface CustomCommand {
    id?: number;
    command: string;
    handler: (args?: any) => void;
    title?: string;
    description?: string;
    args?: CustomCommandArg[];
}
export interface ReactotronCore {
    startTimer: () => () => number;
    close: () => void;
    send: (type: any, payload?: any, important?: boolean) => void;
    display: (config?: any) => void;
    reportError: (this: any, error: any) => void;
    onCustomCommand: (config: CustomCommand | string, optHandler?: () => void) => () => void;
    apiResponse?: (request: any, response: any, duration: any) => void;
    benchmark?: (title: string) => {
        step: (stepName: string) => void;
        stop: (stopTitle: string) => void;
        last: (stopTitle: string) => void;
    };
    clear?: () => void;
    image?: (options: {
        uri: any;
        preview: any;
        filename: any;
        width: any;
        height: any;
        caption: any;
    }) => void;
    log?: (...args: any[]) => void;
    logImportant?: (...args: any[]) => void;
    debug?: (message: any, important?: boolean) => void;
    warn?: (message: any) => void;
    error?: (message: any, stack: any) => void;
    stateActionComplete?: (name: any, action: any, important?: boolean) => void;
    stateValuesResponse?: (path: any, value: any, valid?: boolean) => void;
    stateKeysResponse?: (path: any, keys: any, valid?: boolean) => void;
    stateValuesChange?: (changes: any) => void;
    stateBackupResponse?: (state: any) => void;
    repl?: (name: string, value: object | Function | string | number) => void;
}
export interface Reactotron<ReactotronSubtype = ReactotronCore> extends ReactotronCore {
    /**
     * Set the configuration options.
     */
    configure: (options?: ClientOptions) => Reactotron<ReactotronSubtype> & ReactotronSubtype;
    use: (pluginCreator?: (client: Reactotron<ReactotronSubtype> & ReactotronSubtype) => any) => Reactotron<ReactotronSubtype> & ReactotronSubtype;
    connect: () => Reactotron<ReactotronSubtype> & ReactotronSubtype;
}
export declare class ReactotronImpl<ReactotronSubtype = ReactotronCore> implements Reactotron<ReactotronSubtype> {
    options: ClientOptions;
    /**
     * Are we connected to a server?
     */
    connected: boolean;
    /**
     * The socket we're using.
     */
    socket: WebSocket;
    /**
     * Available plugins.
     */
    plugins: any[];
    /**
     * Messages that need to be sent.
     */
    sendQueue: any[];
    /**
     * Are we ready to start communicating?
     */
    isReady: boolean;
    /**
     * The last time we sent a message.
     */
    lastMessageDate: Date;
    /**
     * The registered custom commands
     */
    customCommands: CustomCommand[];
    /**
     * The current ID for custom commands
     */
    customCommandLatestId: number;
    /**
     * Starts a timer and returns a function you can call to stop it and return the elapsed time.
     */
    startTimer: () => () => number;
    /**
     * Set the configuration options.
     */
    configure(options?: ClientOptions): Reactotron<ReactotronSubtype> & ReactotronSubtype;
    close(): void;
    /**
     * Connect to the Reactotron server.
     */
    connect(): Reactotron<ReactotronSubtype> & ReactotronSubtype;
    /**
     * Sends a command to the server
     */
    send: (type: any, payload?: {}, important?: boolean) => void;
    /**
     * Sends a custom command to the server to displays nicely.
     */
    display(config?: any): void;
    /**
     * Client libraries can hijack this to report errors.
     */
    reportError(this: any, error: any): void;
    /**
     * Adds a plugin to the system
     */
    use(pluginCreator?: (client: Reactotron<ReactotronSubtype> & ReactotronSubtype) => any): Reactotron<ReactotronSubtype> & ReactotronSubtype;
    onCustomCommand(config: CustomCommand | string, optHandler?: () => void): () => void;
}
export declare function createClient<ReactotronSubtype = ReactotronCore>(options?: ClientOptions): Reactotron<ReactotronSubtype> & ReactotronSubtype;
